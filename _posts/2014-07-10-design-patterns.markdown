---
layout: post
category: "java"
title:  "设计模式相关"
tags: [设计模式]
---
### 一、设计原则
1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。（找出程序中会变化的方面，然后将其和固定不变的方面分离。）  
即把会变化的部分取出并封装起来，以便以后可以轻易的改动或扩充此部分，而不影响不需要变化的其它部分。  
2、针对接口编程，而不是针对实现编程。  
即针对超类型编程，变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口。意味着声明类时不用理会以后执行的真正对象类型。  
3、多用组合，少用继承。  
增强系统的弹性，不仅可将算法族封装成类，更可以”在运行时动态的改变行为“，只要组合的行为对象符合正确的接口标准即可。  
4、类应该对扩展开放，对修改关闭。开闭原则。  
5、要依赖抽象，不要依赖具体类。依赖倒置原则。  
6、一个类应该只有一个引起变化的原则。（单一职责）  
不让高层组件依赖低层组件，而且不管高层或低层组件，两者都应该依赖于抽象。

### 二、设计模式
模式是在某情境(context)下，针对某问题的某种解决方案。常见模式有：  
观察者模式：定义了对象之间一对多依赖，这样一来，当一个对象改状态时，它的所有依赖都会收到通知并自动更新。  
装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。  
工厂方法模式：定义了一个创建对象的接口，但子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。  
单件模式：确保一个类只有一个对象，并提供一个全局的访问点。  
命令模式：将”请求“封装成对象，以便使用不同的请求，队列或者日志来参数化其它对象，命令模式也可支持撤销的操作。  
适配器模式：将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。  
模块方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。  
迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。  
组合模式：允许你将对象组合成树形结构来表现”整体/部分"层次结构。组合模式让客户以一致的方式处理个别对象以及对象组合。  
状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。  
代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问。  
复合模式：模式的模式，模式携手合作。

### 三、反模式
告诉你如何用一个不好的解决方案，解决一个问题。  
反模式看起来总像是一个好的解决方案，但当它真正被采用后，就会带来麻烦。  
通过反模式归纳，我们可以帮助代人在实现它们之前，辨出不好的解决方案。  
常见反模式：开发反模式，OO反模式，组织反模式，领域特定反模式。
